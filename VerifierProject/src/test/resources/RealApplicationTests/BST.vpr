domain BST {
  function value(t: BST): Int
  function left(t: BST): BST
  function right(t: BST): BST
  function isNull(t: BST): Bool
  function isNull2(t: BST): Bool // duplicate definition to stop recursion
  function isParent(p: BST, c: BST): Bool

  axiom non_negative_numbers_only {
    forall t: BST :: {value(t)}{isNull(t)} 
      !isNull(t) <==> value(t) >= 0
  }
  axiom isNull_recusive {
    forall t: BST :: {isNull(t)} 
      isNull(t) ==> isNull2(left(t)) && isNull2(right(t))
  }
  axiom isNull2_same {
    forall t: BST :: {isNull2(t)}
      !isNull2(t) <==> value(t) >= 0
  }
  axiom left_smaller {
    forall t: BST :: {value(t), value(left(t))} 
      !isNull(left(t)) ==> value(t) > value(left(t))
  }
  axiom left_sub_tree_smaller {
    forall t: BST, c: BST :: {value(t), value(c)}
      !isNull(t) && !isNull(c) && isParent(left(t), c) ==> value(c) < value(t)
  }
  axiom right_sub_tree_larger {
    forall t: BST, c: BST :: {value(t), value(c)}
      !isNull(t) && !isNull(c) && isParent(right(t), c) ==> value(c) > value(t)
  }
  axiom isParent_reflexive {
    forall t: BST :: {isParent(t,t)}
      isParent(t,t)
  }
  axiom isParent_base {
    forall t: BST :: {isParent(t, left(t))}{isParent(t, right(t))}
      isParent(t, left(t)) && isParent(t, right(t))
  }
  axiom isParent_recursive {
    forall p: BST, c: BST :: {isParent(p, left(c))}{isParent(p, right(c))}
      isParent(p, c) ==> isParent(p, left(c)) && isParent(p, right(c))
  }
  axiom null_not_parent {
    forall p: BST, c: BST :: {isParent(p,c)}
      isParent(p,c) ==> !isNull(p)
  }
}

method getMin(t: BST) returns (min: Int)
  requires !isNull(t)
  requires forall t1: BST :: t1 == t || !isParent(t1, t) // t is root
  ensures forall t1: BST :: {value(t1)}
    !isNull(t1) && isParent(t, t1) ==> value(t1) >= min
{
  var currentNode: BST := t
  while (!isNull(left(currentNode)))
    invariant t == currentNode || isParent(t, currentNode)
    invariant !isNull(currentNode)
    invariant forall t1: BST :: !isNull(t1) && isParent(right(currentNode), t1) ==> value(t1) >= value(currentNode)
    invariant forall pc: BST :: {value(pc), value(currentNode)} 
      isParent(pc, currentNode) ==> value(pc) >= value(currentNode)
  {
    currentNode := left(currentNode)
    assert !isNull(currentNode)
    assert !isNull(left(t)) ==> isParent(left(t), currentNode)
    assert value(currentNode) < value(t)
  }
  min := value(currentNode)
}

