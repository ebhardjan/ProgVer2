domain Matrix {
  // Note: this domain definition only supports square matrices, for simplicity  
  function select(m: Matrix, i: Int, j: Int) : Int
  function store(m:Matrix, i: Int, j:Int, value: Int) : Matrix
  function size(m:Matrix) : Int // only one size function needed for a square matrix (number of rows and number of columns)

  axiom select_store_same {
    forall m: Matrix, i: Int, j:Int, v:Int :: {select(store(m,i,j,v),i,j)} inRange(m,i,j) ==> select(store(m,i,j,v),i,j) == v
  }

  axiom select_store_diff {
    forall m: Matrix, i1: Int, j1:Int, i2: Int, j2:Int, v : Int :: {select(store(m,i1,j1,v),i2,j2)} {select(m,i2,j2),store(m,i1,j1,v)} 
      inRange(m,i1,j1) && inRange(m,i2,j2) && (i1 != i2 || j1 != j2) ==> select(store(m,i1,j1,v),i2,j2) == select(m,i2,j2)
  }

  axiom store_size_same {
      forall m: Matrix, i: Int, j: Int, v: Int :: {size(store(m,i,j,v))} size(m) == size(store(m, i, j, v))
  }
}

// Viper macros get inlined in advance (as part of parsing/checking the program); you don't need to do anything to support them
define inRange(m,i,j) 0 <= i && 0 <= j && i < size(m) && j < size(m)

method add(m1 : Matrix, m2: Matrix) returns (m3:Matrix)
  requires size(m1) > 0
  requires size(m1) == size(m2)
  ensures forall x:Int, y:Int :: {select(m3,x,y)} inRange(m1,x,y) ==> select(m3,x,y) == select(m1,x,y) + select(m2,x,y)  
{
  assume size(m3) == size(m1) // "initialise" m3 to *some* matrix of the right size
  var i : Int := 0
  var j : Int := 0
  // The variables with a '2' in the name are only updated at the beginning of the loop body => they will always remain in range of matrices
  var i2: Int := i
  var j2: Int := j
  
  while(i < size(m1)) 
    invariant inRange(m3, i2, j2) && size(m1) == size(m2) && size(m1) == size(m3) && i >= 0
    // invariant forall x: Int, y: Int :: {select(m3,x,y)} inRange(m3,x,y) && x < i ==> select(m3,x,y) == select(m1,x,y) + select(m2,x,y)
  {
    j := 0
    i2 := i
    while(j < size(m1)) 
      invariant inRange(m3, i2, j2) && size(m1) == size(m3) && j >= 0 
      // invariant forall x: Int, y: Int :: {select(m3,x,y)} inRange(m3,x,y) ==> (select(m3,x,y) == select(m1,x,y) + select(m2,x,y)) || (x >= i || y > j)
    {
      j2 := j
      m3 := store(m3,i2,j2,(select(m1,i2,j2) + select(m2,i2,j2)))
      assert select(m3,i2,j2) == select(m1,i2,j2) + select(m2,i2,j2)
      j := j + 1
    }
    i := i + 1
  }
}
